# Simple Blockchain Implemented Using TypeScript

## Implement Simple Blockchain Structure
In this implementation, we created a minimal working blockchain with core functionalities, such as defining the structure of a block and a blockchain. We included essential block properties like index, data, timestamp, hash, and previousHash. We also implemented methods to generate new blocks, where each block references the hash of the previous one, ensuring data integrity. A genesis block was hardcoded to start the blockchain, and the blocks were stored in memory using a simple JavaScript array. To maintain blockchain integrity, we developed validation methods to check the structure and ensure consistency across blocks.

We also built mechanisms for syncing nodes and communicating with other peers in the network using WebSockets. When a node generates a block, it broadcasts the block to peers, and if a node encounters a longer blockchain, it replaces its own chain with the valid longer one. Additionally, a simple HTTP API was implemented to allow users to interact with the node, enabling them to list blocks, create new blocks, and manage peer connections. This forms the basic foundation of our blockchain, with plans to add proof-of-work in the next stage.

## Proof of Work
We implemented a Proof-of-Work scheme to our blockchain, introducing a computational puzzle that miners must solve before adding a block. This puzzle involves finding a block hash with a specific number of leading zeros, determined by the difficulty level. To solve the puzzle, the `nonce` value is repeatedly changed until a valid hash is found, a process known as mining. The difficulty level ensures control over how frequently new blocks are added by adjusting how hard the puzzle is based on the network's performance.

We also introduced a consensus mechanism for adjusting difficulty every 10 blocks, depending on the time it takes to mine them. If blocks are mined too quickly, the difficulty increases; if too slowly, it decreases. Additionally, we implemented timestamp validation to prevent attacks that manipulate difficulty using false timestamps. Instead of choosing the longest chain as valid, we now select the chain with the highest cumulative difficulty, ensuring that the chain requiring the most computational work is recognized as the correct one.

## Transactions
Now, we introduce transactions, transitioning the blockchain project into a cryptocurrency. Transactions allow the transfer of coins between addresses, which are derived from public keys. This is made possible through public-key cryptography, where users generate a pair of keys: a private key and a public key. Transactions are composed of inputs and outputs; outputs specify the receiver’s address and amount of coins, while inputs provide proof that the sender owns the coins by referencing unspent transaction outputs (uTxOs) from previous transactions. Digital signatures are used to verify the authenticity of transactions without revealing private keys.

To validate transactions, several checks are implemented, including ensuring that the transaction ID is correctly calculated, the input signatures are valid, and the output values match the input values. Additionally, a special coinbase transaction is introduced to reward miners with new coins, serving as the first transaction in every block. However, at this stage, transaction creation is still manual, and transaction fees haven’t been introduced yet. 

## Wallet
Now, we created a simple, unencrypted cryptocurrency wallet that allows users to generate a private key, view their wallet balance, and send coins to other addresses. We started by generating a private key using elliptic curve cryptography (EC) and storing it locally in a file. From this, we derived the public key (wallet address) and implemented a function to calculate the balance by summing up unspent transaction outputs (UTxOs) linked to that address.

We also built functionality for sending coins by constructing transactions that handle both the amount to be sent and any remaining balance returned to the sender. To achieve this, we found the necessary UTxOs, created the transaction inputs (txIns), generated outputs for the recipient and sender (for change), and signed each input with the private key. Finally, we set up a simple API endpoint that allows users to initiate transactions by providing an address and amount, without needing to understand the underlying mechanics.

## Transaction Relaying
Finally, we focus on implementing the relaying of unconfirmed transactions, which are transactions not yet included in the blockchain. The goal is to ensure that transactions can be included in the blockchain without requiring the node itself to mine a block. To achieve this, we introduce a "transaction pool" (or "mempool") where these unconfirmed transactions are stored. Transactions are added to this pool through a new endpoint, POST /sendTransaction. The transactions are then broadcasted across the network, allowing other nodes to be aware of and potentially include them in the blockchain.

We also establish rules for broadcasting and validating these transactions. Nodes will broadcast their transaction pool to peers when they receive new transactions or connect to another node. Validation includes checking that transactions are correctly formatted and that inputs are not already used in other transactions within the pool. As new blocks are mined, the transaction pool is updated to remove any transactions that have become invalid due to being included in a block or having spent outputs. This process ensures that the transaction pool remains current and accurate, facilitating smooth integration of transactions into the blockchain.
